Nice â€” letâ€™s finish the onboarding set. Below are **copy-pasteable WhatsApp Cloud API payloads** (and handling notes) for:

* **Q1 â€” Name** (free-text prompt, with quick-reply hint)
* **Q2 â€” Dietary base** (interactive reply buttons: Veg / Non-Veg / Both)

Each payload uses the same POST endpoint as before. Replace placeholders `<PHONE_NUMBER_ID>`, `<WHATSAPP_TOKEN>`, and `<RECIPIENT_PHONE>`. Iâ€™ll also include the exact webhook-parsing guidance, confirmation copy (Mambo tone), fallback text, and the Supabase field mapping for each question.

---

## Q1 â€” Name (free-text prompt)

### Payload (simple text prompt)

```json
{
  "messaging_product": "whatsapp",
  "to": "<RECIPIENT_PHONE>",
  "type": "text",
  "text": {
    "body": "Mambo ğŸ¥˜: Hey! Iâ€™m Mambo â€” your kitchen sidekick. What should I call you? (Just type your name â€” or reply 'skip' if you prefer.)"
  }
}
```

### Server-side handling (webhook)

* On incoming webhook, check for a normal text message (`message.type === "text"`).
* If user reply text is `"skip"` (case-insensitive), set `name = null` or `"Guest"`.
* Otherwise sanitize the text (trim, capitalize first letter, remove emojis / profanity if any) and store as `name` in Supabase.

### Confirmation reply (send after saving)

```json
{
  "messaging_product": "whatsapp",
  "to": "<RECIPIENT_PHONE>",
  "type": "text",
  "text": {
    "body": "Mambo âœ¨: Lovely â€” Hi {{name}}! Iâ€™ll remember that. Ready for a couple quick preferences so I can tailor your meals? (Yes / No)"
  }
}
```

* Replace `{{name}}` with the stored name. Include Yes/No buttons if you like (see earlier patterns) or wait for text.

### Supabase mapping

* Column: `users.name` (string)
* Upsert by `whatsapp_id` (phone number)

### Fallback

* If client doesnâ€™t send text (e.g., sticker/photo), reply:

  > `I didn't catch your name. Please type your name (or reply 'skip').`

---

## Q2 â€” Dietary base (interactive quick-reply buttons)

Use quick-reply buttons for minimal friction; they map cleanly to enums in DB.

### Payload (interactive buttons)

```json
{
  "messaging_product": "whatsapp",
  "to": "<RECIPIENT_PHONE>",
  "type": "interactive",
  "interactive": {
    "type": "button",
    "body": {
      "text": "Mambo ğŸŒ¿ğŸ—: Tell me your food base â€” what do you usually eat? Tap one."
    },
    "action": {
      "buttons": [
        {
          "type": "reply",
          "reply": {
            "id": "DIET_veg",
            "title": "Veg ğŸŒ±"
          }
        },
        {
          "type": "reply",
          "reply": {
            "id": "DIET_nonveg",
            "title": "Non-Veg ğŸ—"
          }
        },
        {
          "type": "reply",
          "reply": {
            "id": "DIET_both",
            "title": "Both ğŸ´"
          }
        }
      ]
    }
  }
}
```

### Server-side handling (webhook)

* On webhook receipt, extract `interactive.button_reply.id` (or `interactive.reply.id` depending on webhook shape).
* Map:

  * `DIET_veg` â†’ `diet = "veg"`
  * `DIET_nonveg` â†’ `diet = "non-veg"`
  * `DIET_both` â†’ `diet = "both"`
* Upsert to Supabase `users.diet` for the `whatsapp_id`.

### Confirmation reply (Mambo tone)

```json
{
  "messaging_product": "whatsapp",
  "to": "<RECIPIENT_PHONE>",
  "type": "text",
  "text": {
    "body": "Mambo âœ…: Noted â€” you prefer *{{diet_label}}*. Iâ€™ll avoid suggesting meals that donâ€™t match this. Next up: pick a cuisine vibe."
  }
}
```

* `{{diet_label}}` = "Veg ğŸŒ±" / "Non-Veg ğŸ—" / "Both ğŸ´"

### Fallback (if buttons unsupported)

Send numeric menu:

```
Mambo ğŸŒ¿ğŸ—: Reply with number â€” 1 Veg, 2 Non-Veg, 3 Both
```

Then parse incoming text `"1"`, `"2"`, `"3"`.

### Supabase mapping

* Column: `users.diet` (enum/string â€” store `"veg" | "non-veg" | "both"`)

---

## Extra UX & engineering tips (Falguni-style polish + reliability)

1. **One question at a time** â€” Wait for and confirm each answer before sending the next question. Keeps chat clean and feels personal.
2. **Idempotency** â€” If you receive the same answer twice (user taps again), reply with a friendly confirmation instead of duplicating writes.
3. **Save-progress token** â€” Keep a tiny `onboarding_step` field in Supabase so you can resume if the user drops mid-flow. Example values: `0` (not started), `1` (name), `2` (diet), `3` (cuisine), `4` (allergies), `5` (household), `done`.
4. **Persona microcopy** â€” Keep Mambo consistently warm, slightly witty, and short. E.g., â€œMambo âœ¨: Got it!â€ vs dry â€œSaved.â€
5. **Privacy nudge** â€” After onboarding complete, send short consent:

   > â€œI store your preferences (veg, allergies) to personalize suggestions. Reply YES to confirm.â€
   > Store confirmation timestamp in Supabase.
6. **Testing** â€” Use ngrok + sandbox WhatsApp numbers to test flows end-to-end. Log webhook bodies to debug tokens/ids.
7. **Analytics event** â€” Fire `onboarding_completed_step` events to PostHog for each question to see drop-offs.

---

If you want, I can now:

* Provide the **Next.js API route** code for: sending Q1 and Q2 payloads and handling webhook replies to upsert into Supabase; or
* Generate a single **onboarding summary card** message (HTML) to send at the end of all 5 questions (Q1â€“Q5) that looks polished and Nykaa-like.

Which one should I build next?
